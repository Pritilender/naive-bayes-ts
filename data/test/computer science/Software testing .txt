computer science	software testing navigation search software development process software developer requirements specification architecture construction design debugging deployment maintenance methodologies waterfall prototype model incremental iterative model spiral scrum cleanroom rad dsdm agile lean dual vee model tdd bdd fdd ddd mdd configuration management documentation quality assurance project management user experience tools compiler debugger profiler gui designer modeling ide build automation software testing investigation conducted provide stakeholders with information about the quality the product service under software testing can also provide independent view the software allow the business appreciate and understand the risks software test techniques but are not limited the process executing program application with the intent finding software bugs errors other software testing can stated the process validating and verifying that computer meets the requirements that guided its design and works can implemented with the same and satisfies the needs software depending the testing method can implemented any time the software development traditionally most the test effort occurs after the requirements have been defined and the coding process has been but the agile approaches most the test effort the methodology the test governed the chosen software development citation needed contents overview defects and failures input combinations and preconditions economics roles history testing methods static dynamic testing the box approach white box testing black box testing visual testing grey box testing testing levels unit testing integration testing component interface testing system testing acceptance testing testing types installation testing compatibility testing smoke and sanity testing regression testing acceptance testing alpha testing beta testing functional functional testing destructive testing software performance testing usability testing accessibility testing security testing internationalization and localization development testing testing concurrent testing conformance testing type testing testing process traditional waterfall development model agile extreme development model top down and sample testing cycle automated testing testing tools measurement software testing testing artifacts certifications controversy related processes software verification and validation software quality assurance see also references further reading external links overview testing can never completely identify all the defects within instead furnishes criticism comparison that compares the state and behavior the product against oracles principles mechanisms which someone might recognize these oracles may include but are not limited specifications contracts comparable past versions the same inferences about intended expected user customer relevant applicable other primary purpose testing detect software failures that defects may discovered and testing cannot establish that product functions properly under all conditions but can only establish that does not function properly under specific the scope software testing often includes examination code well execution that code various environments and conditions well examining the aspects does what supposed and what needs the current culture software testing organization may separate from the development there are various roles for testing team information derived from software testing may used correct the process which software every software product has target for the audience for video game software completely different from banking therefore when organization develops otherwise invests software can assess whether the software product will acceptable its end its target its purchasers and other software testing the process attempting make this defects and failures not all software defects are caused coding one common source expensive defects requirement unrecognized requirements which result errors omission the program requirement gaps can often non functional requirements such testability scalability maintainability usability performance and security software faults occur through the following programmer makes error which results defect bug the software source code this defect certain situations the system will produce wrong causing failure not all defects will necessarily result for defects dead code will never result defect can turn into failure when the environment examples these changes environment include the software being run new computer hardware platform alterations source data interacting with different single defect may result wide range failure input combinations and preconditions fundamental problem with software testing that testing under all combinations inputs and preconditions initial not even with simple this means that the number defects software product can very large and defects that occur infrequently are difficult find more non functional dimensions quality how supposed versus what supposed usability scalability performance compatibility reliability can highly something that constitutes sufficient value one person may intolerable software developers test but they can use combinatorial test design identify the minimum number tests needed get the coverage they combinatorial test design enables users get greater test coverage with fewer whether they are looking for speed test they can use combinatorial test design methods build structured variation into their test note that coverage used referring combinatorial not requirements economics study conducted nist reports that software bugs cost the economy billion more than third this cost could avoided better software testing was commonly believed that the earlier defect the cheaper fix the following table shows the cost fixing the defect depending the stage was for problem the requirements found only then would cost times more fix than had already been found the requirements with the advent modern continuous deployment practices and based the cost deployment and maintenance may lessen over the data from which this table extrapolated laurent bossavit says his the smaller curve turns out from only two teams year sample size small that extrapolating smaller projects totally the gte study does not explain its other than say came from two one large and one the paper cited for the bell labs project specifically disclaims having collected the grained data that data points the ibm study contains claims which seem contradict and numerical results which clearly correspond his data boehm even cite paper for the trw except when writing for making and there cited the original article there exists large study conducted trw the right time for boehm cite but that paper contain the sort data that would support roles software testing can done software until the the term software was used but later was also seen separate regarding the periods and the different goals software different roles have been manager test lead test analyst test designer tester automation developer and test administrator history the separation debugging from testing was initially introduced glenford myers although his attention was breakage testing successful test one that finds illustrated the desire the software engineering community separate fundamental development such from that dave gelperin and william hetzel classified the phases and goals software testing the following until debugging oriented demonstration oriented destruction oriented evaluation oriented prevention oriented testing methods static dynamic testing there are many approaches available software reviews walkthroughs inspections are referred static testing whereas actually executing programmed code with given set test cases referred dynamic testing static testing often plus when programming text editors check source code structure compilers check syntax and data flow static program analysis dynamic testing takes place when the program itself dynamic testing may begin before the program complete order test particular sections code and are applied discrete functions typical techniques for this are either using stubs drivers execution from debugger environment static testing involves verification whereas dynamic testing involves validation together they help improve software quality among the techniques for static mutation testing can used ensure the cases will detect errors which are introduced mutating the source the box approach software testing methods are traditionally divided into and box these two approaches are used describe the point view that test engineer takes when designing test white box testing white box testing box testing also known clear box testing glass box testing transparent box testing and structural testing tests internal structures workings opposed the functionality exposed the box testing internal perspective the well programming are used design test the tester chooses inputs exercise paths through the code and determine the appropriate this analogous testing nodes circuit testing while box testing can applied the unit integration and system levels the software testing usually done the unit can test paths within paths between units during and between subsystems during level though this method test design can uncover many errors might not detect unimplemented parts the specification missing techniques used box testing api testing application programming testing the application using public and private apis code coverage creating tests satisfy some criteria code coverage the test designer can create tests cause all statements the program executed least fault injection methods intentionally introducing faults gauge the efficacy testing strategies mutation testing methods static testing methods code coverage tools can evaluate the completeness test suite that was created with any including box this allows the software team examine parts system that are rarely tested and ensures that the most important function points have been code coverage software metric can reported percentage function coverage which reports functions executed statement coverage which reports the number lines executed complete the test statement coverage ensures that all code paths branches terms control flow are executed least this helpful ensuring correct but not sufficient since the same code may process different inputs correctly black box testing black box testing box testing treats the software black examining functionality without any knowledge internal the testers are only aware what the software supposed not how does black box testing methods equivalence partitioning boundary value analysis all pairs testing state transition tables decision table testing fuzz testing model based testing use case testing exploratory testing and based specification based testing aims test the functionality software according the applicable this level testing usually requires thorough test cases provided the who then can simply verify that for given the output value either the same the expected value specified the test test cases are built around specifications and what the application supposed uses external descriptions the including requirements and designs derive test these tests can functional non functional though usually specification based testing may necessary assure correct but insufficient guard against complex risk one advantage the black box technique that programming knowledge whatever biases the programmers may have the tester likely has different set and may emphasize different areas the other black box testing has been said like walk dark labyrinth without because they not examine the source there are situations when tester writes many test cases check something that could have been tested only one test leaves some parts the program this method test can applied all levels software unit integration system and acceptance typically comprises most not all testing higher but can also dominate unit testing visual testing the aim visual testing provide developers with the ability examine what was happening the point software failure presenting the data such way that the developer can easily the information she and the information expressed the core visual testing the idea that showing someone problem test rather than just describing greatly increases clarity and visual testing therefore requires the recording the entire test process capturing everything that occurs the test system video output videos are supplemented time tester input via picture webcam and audio commentary from visual testing provides number the quality communication increased dramatically because testers can show the problem and the events leading the developer opposed just describing and the need replicate test failures will cease exist many the developer will have all the evidence she requires test failure and can instead focus the cause the fault and how should visual testing particularly suited for environments that deploy agile methods their development since agile methods require greater communication between testers and developers and collaboration within small citation needed hoc testing and exploratory testing are important methodologies for checking software because they require less preparation time while the important bugs can found hoc where testing takes place impromptu the ability test tool visually record everything that occurs system becomes very clarification needed citation needed visual testing gathering recognition customer acceptance and usability testing because the test can used many individuals involved the development citation needed for the becomes easy provide detailed bug reports and and for program visual testing can record user actions well their voice and provide complete picture the time software failure for the graphical user interface testing box testing gray box testing box testing american gray box testing involves having knowledge internal data structures and algorithms for purposes designing while executing those tests the box the tester not required have full access the source not citation given manipulating input data and formatting output not qualify because the input and output are clearly outside the black that are calling the system under this distinction particularly important when conducting integration testing between two modules code written two different where only the interfaces are exposed for however tests that require modifying end data repository such database log file does qualify the user would not normally able change the data repository normal production citation needed grey box testing may also include reverse engineering for boundary values error knowing the underlying concepts how the software the tester makes informed testing choices while testing the software from typically box tester will permitted set isolated testing environment with activities such seeding database the tester can observe the state the product being tested after performing certain actions such executing sql statements against the database and then executing queries ensure that the expected changes have been grey box testing implements intelligent test based limited this will particularly apply data type exception handling and testing levels there are generally four recognized levels unit integration system and acceptance tests are frequently grouped where they are added the software development the level specificity the the main levels during the development process defined the swebok guide are integration and system testing that are distinguished the test target without implying specific process other test levels are classified the testing unit testing unit testing unit also known component refers tests that verify the functionality specific section usually the function oriented this usually the class and the minimal unit tests include the constructors and these types tests are usually written developers they work code box ensure that the specific function working one function might have multiple catch corner cases other branches the unit testing alone cannot verify the functionality piece but rather used ensure that the building blocks the software work independently from each unit testing software development process that involves synchronized application broad spectrum defect prevention and detection strategies order reduce software development time and performed the software developer engineer during the construction phase the software development rather than replace traditional augments unit testing aims eliminate construction errors before code promoted this strategy intended increase the quality the resulting software well the efficiency the overall development and depending the expectations for software unit testing might include static code analysis data flow metrics peer code code coverage analysis and other software verification integration testing integration testing integration testing any type software testing that seeks verify the interfaces between components against software software components may integrated iterative way all together big normally the former considered better practice since allows interface issues located more quickly and integration testing works expose defects the interfaces and interaction between integrated components progressively larger groups tested software components corresponding elements the architectural design are integrated and tested until the software works component interface testing the practice component interface testing can used check the handling data passed between various subsystem beyond full integration testing between those the data being passed can considered message and the range data types can for data generated from one and tested for validity before being passed into another one option for interface testing keep separate log file data items being often with timestamp logged allow analysis thousands cases data passed between units for days tests can include checking the handling some extreme data values while other interface variables are passed normal unusual data values interface can help explain unexpected performance the next component interface testing variation black box testing with the focus the data values beyond just the related actions subsystem system testing system testing system end tests completely integrated system verify that meets its for system test might involve testing logon then creating and editing plus sending printing followed summary processing deletion then the software testing should ensure that the well working does not also destroy partially corrupt its operating environment cause other processes within that environment become inoperative this includes not corrupting shared not consuming locking excessive resources and leaving any parallel processes unharmed its citation needed acceptance testing acceptance testing last the system delivered the user for acceptance testing types installation testing installation testing installation test assures that the system installed correctly and working actual compatibility testing compatibility testing common cause software failure real lack its compatibility with other application software operating systems operating system versions old target environments that differ greatly from the original such terminal gui application intended run the desktop now being required become web application which must render web browser for the case lack backward compatibility this can occur because the programmers develop and test software only the latest version the target which not all users may this results the unintended consequence that the latest work may not function earlier versions the target older hardware that earlier versions the target environment was capable sometimes such issues can fixed proactively abstracting operating system functionality into separate program module library smoke and sanity testing sanity testing determines whether reasonable proceed with further smoke testing consists minimal attempts operate the designed determine whether there are any basic problems that will prevent from working such tests can used build verification test regression testing regression testing regression testing focuses finding defects after major code change has specifically seeks uncover software regressions degraded lost including old bugs that have come such regressions occur whenever software functionality that was previously correctly stops working typically regressions occur unintended consequence program when the newly developed part the software collides with the previously existing common methods regression testing include running previous sets cases and checking whether previously fixed faults have the depth testing depends the phase the release process and the risk the added they can either for changes added late the release deemed very consisting positive tests each the changes are early the release deemed low regression testing typically the largest test effort commercial software due checking numerous details prior software and even new software can developed while using some old cases test parts the new design ensure prior functionality still acceptance testing acceptance testing acceptance testing can mean one two smoke test used acceptance test prior introducing new build the main testing before integration regression acceptance testing performed the often their lab environment their own known user acceptance testing acceptance testing may performed part the off process between any two phases citation needed alpha testing alpha testing simulated actual operational testing potential customers independent test team the site alpha testing often employed for shelf software form internal acceptance before the software goes beta beta testing beta testing comes after alpha testing and can considered form external user acceptance testing versions the known beta versions are released limited audience outside the programming the software released groups people that further testing can ensure the product has few faults bugs sometimes beta versions are made available the open public increase the feedback field maximal number future citation needed functional functional testing functional testing refers activities that verify specific action function the these are usually found the code requirements although some development methodologies work from use cases user functional tests tend answer the question can the user does this particular feature non functional testing refers aspects the software that may not related specific function user such scalability other performance behavior under certain constraints security testing will determine the breaking the point which extremes scalability performance leads unstable non functional requirements tend those that reflect the quality the particularly the context the suitability perspective its destructive testing destructive testing destructive testing attempts cause the software system verifies that the software functions properly even when receives invalid unexpected thereby establishing the robustness input validation and management citation needed software fault injection the form fuzzing example failure various commercial functional testing tools are linked from the software fault injection page there are also numerous source and free software tools available that perform destructive exception handling recovery testing software performance testing performance testing generally executed determine how system system performs terms responsiveness and stability under particular can also serve measure validate verify other quality attributes the such reliability and resource load testing primarily concerned with testing that the system can continue operate under specific whether that large quantities data large number users this generally referred software scalability the related load testing activity when performed functional activity often referred endurance testing volume testing way test software functions even when certain components for example file increase radically stress testing way test reliability under unexpected rare stability testing often referred load endurance checks see the software can continuously function well above acceptable there little agreement what the specific goals performance testing the terms load performance scalability testing and volume are often used real time software systems have strict timing test timing constraints are real time testing usability testing usability testing check the user interface easy use and concerned mainly with the use the accessibility testing accessibility testing may include compliance with standards such americans with disabilities act section amendment the rehabilitation act web accessibility initiative the world wide web consortium security testing security testing essential for software that processes confidential data prevent system intrusion hackers internationalization and localization the general ability software internationalized and localized can automatically tested without actual using pseudolocalization will verify that the application still even after has been translated into new language adapted for new culture such different currencies time actual translation human languages must too possible localization failures software often localized translating list strings out and the translator may choose the wrong translation for ambiguous source technical terminology may become inconsistent the project translated several people without proper coordination the translator literal word translations may sound artificial too technical the target untranslated messages the original language may left hard coded the source some messages may created automatically run time and the resulting string may functionally misleading software may use keyboard shortcut which has function the source keyboard layout but used for typing characters the layout the target software may lack support for the character encoding the target fonts and font sizes which are appropriate the source language may inappropriate the target for cjk characters may become unreadable the font too string the target language may longer than the software can this may make the string partly invisible the user cause the software crash software may lack proper support for reading writing directional text software may display images with text that was not localized operating systems may have differently named system configuration files and environment variables and different formats for date and currency development testing development testing development testing software development process that involves synchronized application broad spectrum defect prevention and detection strategies order reduce software development time and performed the software developer engineer during the construction phase the software development rather than replace traditional augments development testing aims eliminate construction errors before code promoted this strategy intended increase the quality the resulting software well the efficiency the overall development and depending the expectations for software development testing might include static code analysis data flow analysis metrics peer code unit code coverage traceability and other software verification testing testing concurrent testing concurrent testing conformance testing type testing conformance testing software conformance testing verifies that product performs according its specified compilers for are extensively tested determine whether they meet the recognized standard for that testing process traditional waterfall development model common practice software testing that testing performed independent group testers after the functionality before shipped the this practice often results the testing phase being used project buffer compensate for project thereby compromising the time devoted another practice start software testing the same moment the project starts and continuous process until the project capability maturity model integration waterfall model agile extreme development model some emerging software disciplines such extreme programming and the agile software development movement adhere test driven software development model this unit tests are written the software engineers often with pair programming the extreme programming course these tests fail they are expected then code written passes incrementally larger portions the test the test suites are continuously updated new failure conditions and corner cases are and they are integrated with any regression tests that are unit tests are maintained along with the rest the software source code and generally integrated into the build process with inherently interactive tests being relegated partially manual build acceptance the ultimate goal this test process achieve continuous integration where software updates can published the public this methodology increases the testing effort done before reaching any formal testing some other development most the test execution occurs after the requirements have been defined and the coding process has been top down and bottom testing approach integrated testing where the lowest level components procedures and are tested then integrated and used facilitate the testing higher level after the integration testing lower level integrated the next level modules will formed and can used for integration the process repeated until the components the top the hierarchy are this approach helpful only when all most the modules the same development level are citation needed this method also helps determine the levels software developed and makes easier report testing progress the form citation needed top down testing approach integrated testing where the top integrated modules are tested and the branch the module tested step step until the end the related method stubs and drivers are used for missing components and are replaced the levels are sample testing cycle although variations exist between there typical cycle for the sample below common among organizations employing the waterfall development model the same practices are commonly found other development but might not clear requirements analysis testing should begin the requirements phase the software development life cycle during the design testers work determine what aspects design are testable and with what parameters those tests test planning test strategy test plan testbed creation since many activities will carried out during plan test development test test scenarios test cases test test scripts use testing test execution testers execute the software based the plans and test documents then report any errors found the development test reporting once testing testers generate metrics and make final reports their test effort and whether not the software tested ready for test result analysis defect done the development team usually along with the order decide what defects should fixed rejected found software working deferred dealt with defect retesting once defect has been dealt with the development retested the testing aka resolution testing regression testing common have small test program built subset for each integration modified fixed order ensure that the latest delivery has not ruined and that the software product whole still working test closure once the test meets the exit the activities such capturing the key lessons results logs documents related the project are archived and used reference for future automated testing test automation many programming groups are relying more and more automated testing especially groups that use test driven development there are many frameworks write tests and continuous integration software will run tests automatically every time code checked into version control system while automation cannot reproduce everything that human can and all the ways they think doing can very useful for regression however does require developed test suite testing scripts order truly testing tools program testing and fault detection can aided significantly testing tools and debuggers testing debug tools include features such program permitting full partial monitoring program code instruction set simulator permitting complete instruction level monitoring and trace facilities program animation permitting step execution and conditional breakpoint source level machine code code coverage reports formatted dump symbolic debugging tools allowing inspection program variables error chosen points automated functional gui testing tools are used repeat level tests through the gui benchmarks allowing time performance comparisons made performance analysis profiling that can help highlight hot spots and resource usage some these features may incorporated into integrated development environment measurement software testing software quality quality constrained such topics correctness completeness security citation needed but can also include more technical requirements described under the iso standard iso iec such reliability efficiency portability maintainability compatibility and usability there are number frequently used software metrics which are used assist determining the state the software the adequacy the testing artifacts the software testing process can produce several artifacts test plan test strategy traceability matrix test case test script test suite test fixture test harness certifications several certification programs exist support the professional aspirations software testers and quality assurance certification now offered actually requires the applicant show their ability test certification based widely accepted body this has led some declare that the testing field not ready for certification itself cannot measure their practical and cannot guarantee their professionalism exam based formalized which need can also learned study for istqb qai education based instructor led where each course has passed international institute for software testing citation needed certified associate software testing offered the qai cat certified agile tester offered the international software quality institute cate offered the international institute for software testing certified manager software testing offered the qai certified test manager offered international institute for software testing certified software tester offered the quality assurance institute certified software testing manager global association for quality management accredited via asic accreditation services for international accredited body citation needed post graduate diploma software and mobile testing global association for quality management accredited via asic accreditation services for international accredited body citation needed certified software test professional offered the international institute for software testing cstp australian offered ross associates iseb offered the information systems examinations board citation needed istqb certified foundation level offered the international software testing qualification board istqb certified advanced level offered the international software testing qualification board tmpf tmap next foundation offered the examination institute for information science tmpa tmap next advanced offered the examination institute for information science cmsq offered the quality assurance institute csqa offered the quality assurance institute csqe offered the american society for quality cqia offered the american society for quality controversy some the major software testing controversies include process maturity agile testing waterfall model citation needed test automation test driven development xunit related processes software verification and validation verification and validation software testing used association with verification and validation verification have built the software does implement the validation have built the right the requirements satisfy the the terms verification and validation are commonly used interchangeably the also common see these two terms incorrectly according the ieee standard glossary software engineering according the iso standard software quality assurance software testing part the software quality assurance process software process specialists and auditors are concerned for the software development process rather than just the artifacts such code and they examine and change the software engineering process itself reduce the number faults that end the delivered the called defect what constitutes acceptable defect depends the nature the flight simulator video game would have much higher defect tolerance than software for actual although there are close links with testing departments often exist and there may sqa function some citation needed software testing task intended detect defects software contrasting computer expected results with its actual results for given set quality assurance the implementation policies and procedures intended prevent defects from occurring the first see also book software testing dynamic program analysis formal verification independent test organization manual testing orthogonal array testing pair testing reverse semantic traceability software testability orthogonal defect classification test management tools web testing 