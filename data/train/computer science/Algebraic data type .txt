computer science
algebraic data type algebraic data types navigation search computer programming particularly functional programming and type theory algebraic data type kind composite type type formed combining other two common classes algebraic type are product types tuples and records and sum types also called tagged unions variant types the values product type typically contain several called fields all values that type have the same combination field the set all possible values product type the set theoretical product the sets all possible values its field the values sum type are typically grouped into several called variants value variant type usually created with functional entity called constructor each variant has its own which takes specified number arguments with specified the set all possible values sum type the theoretical the disjoint union the sets all possible values its enumerated types are special case sum types which the constructors take values algebraic types are analyzed with pattern matching which identifies value its constructor field names and extracts the data algebraic data types were introduced hope small functional programming language developed the edinburgh contents examples explanation theory programming languages with algebraic data types see also references examples one the most common examples algebraic data type the singly linked list type sum type with two for empty list and for the combination new element with list create new data abbreviation cons many languages have special syntax for for haskell and use for for and square brackets for entire would normally written for another haskell can define new algebraic data data int here represents empty contains piece and organizes the data into most languages that support algebraic data possible define parametric types examples are given later this somewhat similar data constructor applied arguments appropriate yielding instance the data type which the type constructor for the data constructor logically function meaning that giving integer argument produces value the type takes two arguments the type itself the datatype recursive operations algebraic data types can defined using pattern matching retrieve the for consider function find the depth given here int max thus given can constructed using any and must match for any them respectively deal with all case the pattern extracts the subtrees and for further algebraic data types are particularly suited the implementation abstract syntax for the following algebraic data type describes simple language representing numerical data int element such data type would have form such writing evaluation function for this language simple however more complex transformations also become for optimization pass compiler might written function taking abstract expression input and returning optimized explanation what happening that have which can one several types each type associated with identifier called constructor which can thought kind tag for that kind each constructor can carry with different type constructor could carry data all empty the example carry one piece data has one int multiple pieces data has two tree when want something with value this tree algebraic data deconstruct using process known pattern involves matching the data with series patterns the example function depth above matches its argument with three when the function finds the first pattern that matches its performs any variable bindings that are found the and evaluates the expression corresponding the each pattern has form that resembles the structure some possible value this the first pattern above simply matches values the constructor the second pattern above matches values the constructor patterns are then the data that associated with that constructor matched with the pattern this lowercase identifier represents pattern that matches any which then bound variable that name this variable bound the integer value stored the data type used the expression the recursion patterns this example are but possible more complex recursive pattern would something like node node leaf node node empty recursive patterns several layers deep are used for example balancing red black trees which involve cases that require looking colors several layers the example above operationally equivalent the following the comparison this with pattern matching will point out some the advantages algebraic data types and pattern first type safety the pseudocode above relies the diligence the programmer not access when the constructor for also the type different for leaf and node for leaf for node the type system would have difficulties assigning static type safe way traditional record data however pattern the type each extracted value checked based the types declared the relevant and how many values you can extract known based the does not face these second pattern the compiler statically checks that all cases are one the cases the function above were the compiler would issue indicating that case not this task may seem easy for the simple patterns but with many complicated recursive the task becomes difficult for the average human has check arbitrary nested else similarly there may patterns which never match already covered previous and the compiler can also check and issue warnings for they may indicate error not confuse these patterns with regular expression patterns used string pattern the purpose similar check whether piece data matches certain and extract relevant parts for processing but the mechanism very this kind pattern matching algebraic data types matches the structural properties object rather than the character sequence theory recursive data type general algebraic data type possibly recursive sum type product types each constructor tags product type separate from there only one the data type product further the parameter types constructor are the factors the product parameterless constructor corresponds the empty product datatype the entire sum products wrapped recursive type and each constructor also rolls the datatype into the recursive for the haskell data represented type theory with constructors and the haskell list datatype can also represented type theory slightly different note how the and constructs are reversed relative the the original formation specified type function whose body was recursive the revised version specifies recursive function use the type variable suggest function rather than base like since like greek note that must also now apply the function its argument type the body the for the purposes the list these two formulations are not significantly but the second form allows one express called nested data types those where the recursive type differs parametrically from the for more information nested data see the works richard bird lambert meertens and ross set theory the equivalent sum type disjoint union set whose elements are pairs consisting tag equivalent and object type corresponding the tag equivalent the constructor programming languages with algebraic data types the following programming languages have algebraic data types first class clean ceylon haskell haxe hope lotos mercury miranda nemerle ocaml opa racket rust scala standard swift tom visual prolog see also tagged union disjoint union type theory generalized algebraic data type initial algebra quotient type 