computer science
functional programming navigation search procedural programming programming paradigms action oriented oriented based concurrent computing relativistic programming driven declarative imperative constraint dataflow flow based oriented spreadsheets reactive functional logic logic abductive logic answer set constraint logic functional logic inductive logic user programming driven service oriented driven oriented oriented level value level generic imperative declarative procedural oriented natural language programming specific specific oriented dialecting intentional metaprogramming automatic reflective attribute oriented homoiconic template policy based structured structured array nondeterministic parallel computing process oriented free style concatenative semantic structured non structured block structured modular monolithic object oriented separation concerns aspect oriented oriented oriented based based recursive level function level probabilistic concept computer science functional programming programming paradigm style building the structure and elements computer that treats computation the evaluation mathematical functions and avoids state and mutable data declarative programming paradigm which means programming done with expressions functional the output value function depends only the arguments that are input the calling function twice with the same value for argument will produce the same result both eliminating side effects changes state that not depend the function can make much easier understand and predict the behavior which one the key motivations for the development functional functional programming has its roots lambda calculus formal system developed the investigate computability the entscheidungsproblem function function and recursion many functional programming languages can viewed elaborations the lambda the other well known declarative programming paradigm logic programming relations are the base respective imperative programming changes state with commands the source the most simple example the functions not the mathematical but the sense subroutine they can have side effects that may change the value program functions without return value therefore make because they lack referential transparency the same language expression can result different values different times depending the state the executing functional programming especially purely functional ones such hope and rex have largely been emphasized academia rather than commercial software however prominent functional programming languages such common lisp scheme clojure racket erlang ocaml haskell and have been used industrial and commercial applications wide variety functional programming also supported some domain specific programming languages like mathematica symbolic and numeric and from systems financial xquery xslt xml and widespread specific declarative languages like sql and lex yacc use some elements functional especially eschewing mutable values programming functional style can also accomplished languages that specifically designed for functional for the imperative perl programming language has been the subject book describing how apply functional programming and java added constructs facilitate the functional interesting case that scala frequently written functional but the presence side effects and mutable state place grey area between imperative and functional contents history concepts first class and order functions pure functions recursion strict versus strict evaluation type systems functional programming functional languages comparison imperative programming simulating state efficiency issues coding styles haskell erlang lisp use industry see also references further reading external links history lambda calculus provides theoretical framework for describing functions and their although mathematical abstraction rather than programming forms the basis almost all functional programming languages equivalent theoretical combinatory logic commonly perceived more abstract than lambda calculus and preceded combinatory logic and lambda calculus were both originally developed achieve clearer approach the foundations mathematics early flavored language was lisp developed john mccarthy while massachusetts institute technology for the ibm series scientific computers the late lisp introduced many features now found functional though lisp technically paradigm scheme and dylan were later attempts simplify and improve information processing language sometimes cited the first based functional programming style language for manipulating lists does have notion generator which amounts function accepting function and since level code can used ipl can regarded having order however relies heavily mutating list structure and similar imperative kenneth iverson developed apl the early described his book programming language isbn apl was the primary influence john backus the early iverson and roger hui created the arthur whitney who had previously worked with created which used commercially financial industries along with its descendant john backus presented his turing award lecture can programming liberated from the von neumann style functional style and its algebra defines functional programs being built hierarchical way means combining that allow algebra modern this means that functional programs follow the principle compositionality backus paper popularized research into functional though emphasized function level programming rather than the calculus style which has come associated with functional the was created robin milner the university edinburgh and david turner initially developed the language sasl the university andrews and later the language miranda the university kent also edinburgh the burstall and darlington developed the functional language npl npl was based kleene recursion equations and was first introduced their work program burstall macqueen and sannella then incorporated the polymorphic type checking from produce the language hope eventually developed into several the most common which are now ocaml and standard meanwhile the development scheme partly functional dialect described the influential lambda papers and the textbook structure and interpretation computer programs brought awareness the power functional programming the wider languages the per developed intuitionistic type theory also called constructive type which associated functional programs with constructive proofs arbitrarily complex mathematical propositions expressed dependent types this led powerful new approaches interactive theorem proving and has influenced the development many subsequent functional programming the haskell language began with consensus form open standard for functional programming implementation releases have been ongoing since concepts number concepts and paradigms are specific functional and generally foreign imperative programming including object oriented programming however programming languages are often hybrids several programming programmers using mostly languages may have utilized some these first class and order functions first class function order function order functions are functions that can either take other functions arguments return them example order function the differential operator which returns the derivative function higher order functions are closely related first class functions that order functions and class functions both allow functions arguments and results other the distinction between the two describes mathematical concept functions that operate other while computer science term that describes programming language entities that have restriction their use thus class functions can appear anywhere the program that other class entities like numbers including arguments other functions and their return higher order functions enable partial application currying technique which function applied its arguments one with each application returning new function that accepts the next this allows one succinctly for the successor function the addition operator partially applied the natural number one pure functions purely functional functions have side effects memory this means that pure functions have several useful many which can used optimize the the result pure expression not can removed without affecting other pure function called with arguments that cause the result constant with respect that argument list sometimes called referential transparency the pure function again called with the same the same result will returned this can enable caching optimizations such memoization there data dependency between two pure then their order can they can performed parallel and they cannot interfere with one another other the evaluation any pure expression thread safe the entire language does not allow then any evaluation strategy can this gives the compiler freedom reorder combine the evaluation expressions program for using deforestation while most compilers for imperative programming languages detect pure functions and perform subexpression elimination for pure function they cannot always this for compiled which generally not expose this thus preventing optimizations that involve those external some such gcc add extra keywords for programmer explicitly mark external functions enable such fortran also allows functions designated pure recursion recursion computer iteration functional languages usually accomplished via recursion recursive functions invoke allowing operation performed over and over until the base case though some recursion requires maintaining tail recursion can recognized and optimized compiler into the same code used implement iteration imperative the scheme language standard requires implementations recognize and optimize tail tail recursion optimization can implemented transforming the program into continuation passing style during among other common patterns recursion can factored out using higher order with catamorphisms and anamorphisms folds and unfolds being the most obvious such higher order functions play role analogous control structures such loops imperative languages most general purpose functional programming languages allow unrestricted recursion and are turing complete which makes the halting problem undecidable can cause unsoundness equational reasoning and generally requires the introduction inconsistency into the logic expressed the type system some special purpose languages such coq allow only well founded recursion and are strongly normalizing nonterminating computations can expressed only with infinite streams values called codata these languages fail turing complete and expressing certain functions them but they can still express wide class interesting computations while avoiding the problems introduced unrestricted functional programming limited founded recursion with few other constraints called total functional programming see turner for more strict versus strict evaluation evaluation strategy functional languages can categorized whether they use strict non strict evaluation concepts that refer how function arguments are processed when expression being the technical difference the denotational semantics expressions containing failing divergent under strict the evaluation any term containing failing subterm will itself for the will fail under strict evaluation because the division zero the third element the under lazy the length function will return the value the number items the since evaluating will not attempt evaluate the terms making the strict evaluation always fully evaluates function arguments before invoking the lazy evaluation does not evaluate function arguments unless their values are required evaluate the function call the usual implementation strategy for lazy evaluation functional languages graph reduction lazy evaluation used default several pure functional including miranda clean and haskell hughes argues for lazy evaluation mechanism for improving program modularity through separation concerns easing independent implementation producers and consumers data launchbury describes some difficulties that lazy evaluation particularly analyzing storage and proposes operational semantics aid such harper proposes including both strict and lazy evaluation the same using the type system distinguish type systems especially since the development hindley milner type inference the functional programming languages have tended use typed lambda calculus opposed the untyped lambda calculus used lisp and its variants such scheme the use algebraic datatypes and pattern matching makes manipulation complex data structures convenient and the presence strong time type checking makes programs more while type inference frees the programmer from the need manually declare types the some oriented functional languages such coq agda cayenne and epigram are based intuitionistic type theory which allows types depend such types are called dependent types these type systems not have decidable type inference and are difficult understand and program with citation needed but dependent types can express arbitrary propositions predicate logic through the curry howard isomorphism then well typed programs these languages become means writing formal mathematical proofs from which compiler can generate certified code while these languages are mainly interest academic research including formalized mathematics they have begun used engineering compcert compiler for subset the programming language that written coq and formally limited form dependent types called generalized algebraic data types can implemented way that provides some the benefits dependently typed programming while avoiding most its gadt are available the glasgow haskell compiler ocaml since version and scala case and have been proposed additions other languages including java and functional programming functional languages possible use functional style programming languages that are not traditionally considered functional for both and fortran explicitly support pure first class functions have slowly been added mainstream for early support for filter map and reduce was added python then during the development python guido van rossum called for the removal these however later changed his and only reduce was though remains accessible via the standard library first class functions were also introduced php visual basic and java anonymous classes can sometimes used simulate closures however anonymous classes are not always proper replacements closures because they have more limited java supports lambda expressions replacement for some anonymous however the presence checked exceptions java can make functional programming because can necessary catch checked exceptions and then rethrow problem that does not occur other jvm languages that not have checked such citation needed many object oriented design patterns are expressible functional programming for the strategy pattern simply dictates use order and the visitor pattern roughly corresponds catamorphism fold similarly the idea immutable data from functional programming often included imperative programming for example the tuple which immutable comparison imperative programming functional programming very different from imperative programming the most significant differences stem from the fact that functional programming avoids side effects which are used imperative programming implement state and pure functional programming completely prevents effects and provides referential transparency which makes easier optimize and parallelize and easier write automated tools perform those higher order functions are rarely used older imperative where traditional imperative program might use loop traverse functional program would use different would use order function that takes arguments function and the order function would then apply the given function each element the given list and then return new list with the simulating state there are tasks for maintaining bank account that often seem most naturally implemented with pure functional programming performs these and tasks such accepting user input and printing the different the pure functional programming language haskell implements them using monads derived from category theory monads offer way abstract certain types computational including but not limited modeling computations with mutable state and other side effects such imperative manner without losing while existing monads may easy apply given appropriate templates and many students find them difficult understand when asked define new monads which sometimes needed for certain types another way which functional languages can simulate state passing around data structure that represents the current state parameter function each function copy this data structure created with whatever differences are the result the this referred state passing style impure functional languages usually include more direct method managing mutable clojure for uses managed references that can updated applying pure functions the current this kind approach enables mutability while still promoting the use pure functions the preferred way express alternative methods such hoare logic and uniqueness have been developed track side effects some modern research languages use effect systems make the presence side effects efficiency issues functional programming languages are typically less efficient their use cpu and memory than imperative languages such and pascal this related the fact that some mutable data structures like arrays have very straightforward implementation using present hardware which highly evolved turing flat arrays may accessed very efficiently with deeply pipelined prefetched efficiently through caches with complex handled with simd and not easy create their equally efficient purpose immutable for purely functional the case slowdown logarithmic the number memory cells because mutable memory can represented purely functional data structure with logarithmic access time such balanced however such slowdowns are not for programs that perform intensive numerical functional languages such ocaml and clean are only slightly slower than for programs that handle large matrices and multidimensional databases array functional languages such and were designed with speed immutability data can many cases lead execution efficiency allowing the compiler make assumptions that are unsafe imperative thus increasing opportunities for inline expansion lazy evaluation may also speed the even whereas may slow down most constant factor may introduce memory leaks used launchbury discusses theoretical issues related memory leaks from lazy and sullivan give some practical advice for analyzing and fixing however the most general implementations lazy evaluation making extensive use dereferenced code and data perform poorly modern processors with deep pipelines and level caches where cache miss may cost hundreds citation needed coding styles this section does not cite any references sources please help improve this section adding citations reliable sources unsourced material may challenged and removed july imperative programs tend emphasize the series steps taken program carrying out while functional programs tend emphasize the composition and arrangement often without specifying explicit steps simple example illustrates this with two solutions the same programming goal calculating fibonacci numbers the imperative example python version with generators fibonacci imperative style def for range yield return current iteration print for version normal def for range print print current iteration calculate next values version recursive def return else return print haskell functional version haskell has different feel fibonacci functional style describe infinite list based the recurrence relation for fibonacci numbers describe fibonacci list fibrecurrence with initial values and describe action print the element the fibonacci list print more zipwith tail the imperative style describes the intermediate steps involved calculating and places those steps inside loop statement the functional implementation shown here states the mathematical recurrence relation that defines the entire fibonacci then selects element from the sequence see also recursion this example relies lazy evaluation create infinite list which only much needed the first elements this will actually that computation happens when the runtime system carries out the action described main erlang lyme software erlang the same program erlang provides simple example how functional languages general not require their syntax contain statement module export fibonacci numbers erlang start fib fib fib fib this program contained within module called fibonacci and declares that the function will visible from outside the scope this the function accepts single parameter denoted the syntax and then calls internal function called direct contrast the imperative coding erlang does not need statement because the erlang runtime will examine the parameters being passed and call the first function having signature that matches the current pattern erlang syntax does provide statement but considered syntactic sugar compared its usage imperative plays only minor role application logic this unnecessary test for parameter value within the body the function because such test implicitly performed providing set function signatures that describe the different patterns values that could received the case the first version will only called when the third parameter has the precise value all other the second version will this example demonstrates that functional programming languages often implement conditional logic implicitly matching parameter patterns rather than explicitly means statement lisp the fibonacci function can written common lisp defun the program can then called use industry functional programming has long been popular but with few industrial however recently several prominent functional programming languages have been used commercial industrial for the erlang programming which was developed the swedish company ericsson the late was originally used implement tolerant telecommunications has since become popular for building range applications companies such mobile nortel facebook france and whatsapp the scheme dialect lisp was used the basis for several applications early apple macintosh computers and has more recently been applied problems such training simulation software and telescope control ocaml which was introduced the has seen commercial use areas such financial driver verification industrial robot programming and static analysis embedded software haskell although initially intended research has also been applied range areas such aerospace hardware and web other functional programming languages that have seen use industry include scala which hybrid language and has support for both purely functional and imperative lisp standard and clojure see also comparison programming paradigms eager evaluation list functional programming topics nested function inductive functional programming functional reactive programming 