computer science	versus problem problem navigation search list unsolved problems computer science the solution problem can quickly verified can the computer also solve that problem millennium prize problems hodge conjecture conjecture riemann hypothesis mills existence and mass gap stokes existence and smoothness birch and dyer conjecture theorem the versus problem major unsolved problem computer science informally asks whether every problem whose solution can quickly verified computer can also quickly solved was introduced stephen cook his seminal paper the complexity theorem proving and considered many the most important open problem the one the seven millennium prize problems selected the clay mathematics institute carry prize for the first correct the informal term quickly used above means the existence algorithm for the task that runs polynomial time the general class questions for which some algorithm can provide answer polynomial time called class just for some there known way find answer but one provided with information showing what the answer may possible verify the answer the class questions for which answer can verified polynomial time called consider the subset sum problem example problem that easy but whose answer may difficult given set integers does some nonempty subset them sum for does subset the set add the answer because adds can quickly verified with three however there known algorithm find such subset polynomial time there however exponential time which consists tries but such algorithm exists hence this problem quickly but not necessarily quickly answer the question would determine whether problems that can verified polynomial like the sum can also solved polynomial turned out that would mean that there are problems such complete problems that are harder compute than they could not solved polynomial but the answer could verified polynomial aside from being important problem computational proof either way would have profound implications for cryptography algorithm artificial intelligence game theory multimedia philosophy economics and many other contents context complete harder problems problems not known complete does mean easy reasons believe consequences the resolution the problem results about difficulty proof claimed solutions logical characterizations polynomial time algorithms formal definitions for and example formal definition for completeness popular culture see also references notes further reading external links context the relation between the complexity classes and studied computational complexity theory the part the theory computation dealing with the resources required during computation solve given the most common resources are time how many steps takes solve and space how much memory takes solve such model the computer for which time must analyzed typically such models assume that the computer deterministic given the present state and any there only one possible action that the computer might and sequential performs actions one after the this the class consists all those decision problems defined below that can solved deterministic sequential machine amount time that polynomial the size the the class consists all those decision problems whose positive solutions can verified polynomial time given the right whose solution can found polynomial time non deterministic machine clearly arguably the biggest open question theoretical computer science concerns the relationship between those two poll researchers believed the answer believed the answer and were believed the question may independent the currently accepted axioms and therefore impossible prove years the same poll was the number researchers who answered was believed the answer believed the answer believed the question may independent the currently accepted axioms and therefore impossible prove said either know care want the answer yes nor the problem complete euler diagram complete attack the question the concept completeness very complete problems are set problems each which any other problem can reduced polynomial and whose solution may still verified polynomial that any problem can transformed into any the complete informally complete problem problem that least tough any other problem hard problems are those least hard problems all problems can reduced polynomial hard problems need not they need not have solutions verifiable polynomial for the boolean satisfiability problem complete the cook levin theorem any instance any problem can transformed mechanically into instance the boolean satisfiability problem polynomial the boolean satisfiability problem one many such complete any complete problem then would follow that unfortunately many important problems have been shown and not single fast algorithm for any them based the definition alone not obvious that complete problems trivial and contrived complete problem can formulated given description turing machine guaranteed halt polynomial does there exist size input that will because given simple check whether accepts the input simulating complete because the verifier for any particular instance problem can encoded time machine that takes the solution verified then the question whether the instance yes instance determined whether valid input the first natural problem proven complete was the boolean satisfiability problem noted this the cook levin theorem its proof that satisfiability complete contains technical details about turing machines they relate the definition however after this problem was proved proof reduction provided simpler way show that many other problems are also including the subset sum problem discussed thus vast class seemingly unrelated problems are all reducible one and are sense the same harder problems complexity class although unknown whether problems outside are number succinct problems problems that operate not normal but computational description the are known exptime complete because can shown that exptime these problems are outside and require more than polynomial the time hierarchy theorem they cannot solved significantly less than exponential examples include finding perfect strategy for chess board and some other board the problem deciding the truth statement presburger arithmetic requires even more fischer and rabin proved that every algorithm that decides the truth presburger statements has runtime least for some constant here the length the presburger hence the problem known need more than exponential run even more difficult are the undecidable problems such the halting problem they cannot completely solved any the sense that for any particular algorithm there least one input for which that algorithm will not produce the right will either produce the wrong finish without giving conclusive otherwise run forever without producing any answer problems not known complete intermediate was shown ladner that then there exist problems that are neither nor such problems are called intermediate the graph isomorphism problem the discrete logarithm problem and the integer factorization problem are examples problems believed they are some the very few problems not known the graph isomorphism problem the computational problem determining whether two finite graphs are isomorphic important unsolved problem complexity theory whether the graph isomorphism problem the answer not but believed that the problem least not graph isomorphism the polynomial time hierarchy collapses its second since widely believed that the polynomial hierarchy does not collapse any finite believed that graph isomorphism not the best algorithm for this due laszlo babai and eugene luks has run time for graphs with vertices the integer factorization problem the computational problem determining the prime factorization given phrased decision the problem deciding whether the input has factor less than efficient integer factorization algorithm and this fact forms the basis several modern cryptographic such the rsa algorithm the integer factorization problem and and even and the problem the polynomial time hierarchy will collapse its first level the best known algorithm for integer factorization the general number field sieve which takes expected time factor bit however the best known quantum algorithm for this shor algorithm does run polynomial unfortunately this fact say much about where the problem lies with respect quantum complexity does mean easy all the above discussion has assumed that means easy and not means hard assumption known cobham thesis common and reasonably accurate assumption complexity however has some first not always true theoretical polynomial algorithm may have extremely large constant factors exponents thus rendering the other even problem shown and even there may still effective approaches tackling the problem there are algorithms for many complete such the knapsack problem the traveling salesman problem and the boolean satisfiability problem that can solve optimality many world instances reasonable the empirical average case complexity time problem such algorithms can surprisingly famous example the simplex algorithm linear programming which works surprisingly well despite having exponential case time complexity runs par with the best known time second there are types computations which not conform the turing machine model which and are such quantum computation and randomized algorithms reasons believe according many computer scientists believe that key reason for this belief that after decades studying these problems one has been able find time algorithm for any more than important known complete problems see list complete problems these algorithms were sought long before the concept completeness was even defined karp complete problems among the first were all known existing problems the time they were shown furthermore the result would imply many other startling results that are currently believed such and also intuitively argued that the existence problems that are hard solve but for which the solutions are easy verify matches world then the world would profoundly different place than usually assume there would special value creative fundamental gap between solving problem and recognizing the solution once scott aaronson mit the other some researchers believe that there overconfidence believing and that researchers should explore proofs for these statements were the main argument favor the total lack fundamental progress the area exhaustive this very weak the space algorithms very large and are only the beginning its the resolution fermat last theorem also shows that very simple questions may settled only very deep moshe vardi rice university being attached speculation not good guide research one should always try both directions every prejudice has caused famous mathematicians fail solve famous problems whose solution was opposite their even though they had developed all the methods anil nerode cornell university consequences the resolution the problem one the reasons the problem attracts much attention the consequences the either direction resolution would advance theory and perhaps have huge practical consequences proof that could have stunning practical the proof leads efficient methods for solving some the important problems also possible that proof would not lead directly efficient perhaps the proof non constructive the size the bounding polynomial too big efficient the both positive and arise since various complete problems are fundamental many cryptography for relies certain problems being constructive and efficient solution note complete problem such sat would break most existing cryptosystems public key cryptography foundation for many modern security applications such secure economic transactions over the and symmetric ciphers such aes des used for the encryption communications these would need modified replaced information theoretically secure solutions the other there are enormous positive consequences that would follow from rendering tractable many currently mathematically intractable for many problems operations research are such some types integer programming and the travelling salesman problem name two the most famous efficient solutions these problems would have enormous implications for many other important such some problems protein structure prediction are also these problems were efficiently solvable could spur considerable advances but such changes may pale significance compared the revolution efficient method for solving complete problems would cause mathematics his early thoughts computational noted that mechanical method that could solve any problem would revolutionize there really were machine with even this would have consequences the greatest namely would obviously mean that spite the undecidability the the mental work mathematician concerning questions could completely replaced after one would simply have choose the natural number large that when the machine does not deliver makes sense think more about the similarly stephen cook says would transform mathematics allowing computer find formal proof any theorem which has proof reasonable since formal proofs can easily recognized polynomial example problems may well include all the cmi prize problems research mathematicians spend their careers trying prove and some proofs have taken decades even centuries find after problems have been for fermat last theorem took over three centuries method that guaranteed find proofs should one exist reasonable size would essentially end this proof that showed that would lack the practical computational benefits proof that but would nevertheless represent very significant advance computational complexity theory and provide guidance for future would allow one show formal way that many common problems cannot solved that the attention researchers can focused partial solutions solutions other due widespread belief much this focusing research has already taken also still leaves open the average case complexity hard problems for possible that sat requires exponential time the worst but that almost all randomly selected instances are efficiently russell impagliazzo has described five hypothetical worlds that could result from different possible resolutions the case complexity these range from algorithmica where and problems like sat can solved efficiently all cryptomania where and generating hard instances problems outside with three intermediate possibilities reflecting different possible distributions difficulty over instances hard problems the world where but all problems are tractable the average case called heuristica the princeton university workshop studied the status the five results about difficulty proof although the problem itself remains open despite dollar prize and huge amount dedicated efforts solve the problem have led several new some the most fruitful research related the problem has been showing that existing proof techniques are not powerful enough answer the thus suggesting that novel technical approaches are additional evidence for the difficulty the essentially all known proof techniques computational complexity theory fall into one the following each which known insufficient prove that relativizing proofs oracle relativizing solovay natural proofs alexander razborov steven rudich natural proofs way functions pspace scott aaronson avi wigderson pspace arithmetization these barriers are another reason why complete problems are time algorithm can demonstrated for complete this would solve the problem way not excluded the above these barriers have also led some computer scientists suggest that the versus problem may independent standard axiom systems like zfc cannot proved disproved within the interpretation independence result could that either time algorithm exists for any complete and such proof cannot constructed zfc that time algorithms for complete problems may but impossible prove zfc that such algorithms are however can using techniques the sort that are currently known that the problem cannot decided even with much weaker assumptions extending the peano axioms for integer then there would necessarily exist time algorithms for every problem therefore one believes most complexity theorists that not all problems have efficient would follow that proofs independence using those techniques cannot additionally this result implies that proving independence from zfc using currently known techniques easier than proving the existence efficient algorithms for all problems claimed solutions while the versus problem generally considered many amateur and some professional researchers have claimed woeginger has comprehensive august claim proof that vinay researcher labs palo alto received heavy internet and press attention after being initially described seem relatively serious two leading the proof has been reviewed publicly and neil immerman expert the had pointed out two possibly fatal errors the september deolalikar was reported working detailed expansion his attempted however opinions expressed several notable theoretical computer scientists indicate that the attempted proof neither correct nor significant advancement the understanding the this assessment prompted may the new yorker article call the proof attempt thoroughly logical characterizations the problem can restated terms expressible certain classes logical result work descriptive complexity consider all language finite structures with fixed signature including linear order relation then all such languages can expressed first order logic with the addition suitable least fixed point combinator effectively this combination with the allows the definition recursive long the signature contains least one predicate function addition the distinguished order that the amount space taken store such finite structures actually polynomial the number elements the this precisely characterizes similarly the set languages expressible existential second order logic that second order logic restricted exclude universal quantification over functions and the languages the polynomial hierarchy correspond all order thus the question proper subset can reformulated existential order logic able describe languages finite linearly ordered structures with nontrivial that order logic with least fixed point the word existential can even dropped from the previous since and only the former would establish that which turn implies that polynomial time algorithms algorithm for any complete problem known run polynomial however there are algorithms for complete problems with the property that then the algorithm runs polynomial time although with enormous making the algorithm the following due levin without any such example correctly accepts the complete language subset sum runs polynomial time and only and only then this time algorithm accepting complete accepting means gives yes answers polynomial but allowed run forever when the answer also known semi algorithm this algorithm enormously even the shortest program that can solve sum polynomial time bits the above algorithm will try least other programs formal definitions for and conceptually decision problem problem that takes input some string over alphabet and outputs yes there algorithm say turing machine computer program with unbounded that can produce the correct answer for any input string length most steps where and are constants independent the input then say that the problem can solved polynomial time and place the class formally defined the set all languages that can decided deterministic time turing that where and deterministic time turing machine deterministic turing machine that satisfies the following two halts all input and there exists such that where refers the big notation and can defined similarly using nondeterministic turing machines the traditional however modern approach define use the concept certificate and verifier formally defined the set languages over finite alphabet that have verifier that runs polynomial where the notion verifier defined let language over finite and only there exists binary relation and positive integer such that the following two conditions are for all such that and and the language over decidable turing machine polynomial turing machine that decides called verifier for and such that called certificate membership verifier does not have however for there must verifier that runs polynomial example let the question whether given composite equivalent the question whether member can shown that composite verifying that satisfies the above definition identify natural numbers with their binary composite also happens formal definition for completeness there are many equivalent ways describing let language over finite alphabet complete and only the following two conditions are and any reducible written where and only the following two conditions are there exists such that for all and there exists time turing machine that halts with its tape any input popular culture the film travelling salesman director timothy the story four mathematicians hired the government solve the the cbs series numbers was said that charlie epps spent the last three months his life the unable face working misguidedly thinking that may able cure her the cbs series elementary season episode entitled solve for and originally broadcast october the search for solution the problem and its value the computer world used motive for double see also game complexity unique games conjecture unsolved problems computer science unsolved problems mathematics 