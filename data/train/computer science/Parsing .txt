computer science
parsing navigation search parse parser cgi parsing syntactic analysis the process analysing string either natural language computer languages according the rules formal grammar the term parsing comes from latin pars orationis meaning part the term has slightly different meanings different branches linguistics and computer science traditional sentence parsing often performed method understanding the exact meaning sometimes with the aid devices such sentence diagrams usually emphasizes the importance grammatical divisions such subject and predicate within computational linguistics the term used refer the formal analysis computer sentence other string words into its resulting parse tree showing their syntactic relation each which may also contain semantic and other the term also used psycholinguistics when describing language this parsing refers the way that human beings analyze sentence phrase spoken language terms grammatical identifying the parts syntactic etc this term especially common when discussing what linguistic cues help speakers interpret garden path sentences within computer the term used the analysis computer languages referring the syntactic analysis the input code into its component parts order facilitate the writing compilers and interpreters contents human languages traditional methods computational methods psycholinguistics computer languages parser overview process types parsers examples parsers top down parsers bottom parsers parser development software lookahead see also references further reading external links human languages natural language parsing traditional methods the traditional grammatical exercise sometimes known clause analysis involves breaking down text into its component parts speech with explanation the function and syntactic relationship each this determined large part from study the conjugations and declensions which can quite intricate for heavily inflected parse phrase such man bites involves noting that the singular noun the subject the the verb the third person singular the present tense the verb and the singular noun the object the techniques such sentence diagrams are sometimes used indicate relation between elements the parsing was formerly central the teaching grammar throughout the speaking and widely regarded basic the use and understanding written however the teaching such techniques longer computational methods this section does not cite any references sources please help improve this section adding citations reliable sources unsourced material may challenged and removed february natural language parsing some machine translation and natural language processing systems written texts human languages are parsed computer programs clarification needed human sentences are not easily parsed there substantial ambiguity the structure human whose usage convey meaning semantics amongst potentially unlimited range possibilities but only some which are germane the particular utterance man bites versus dog bites definite one detail but another language might appear man dog with reliance the larger context distinguish between those two indeed that difference was difficult prepare formal rules describe informal behaviour even though clear that some rules are being order parse natural language researchers must first agree the grammar the choice syntax affected both linguistic and computational for instance some parsing systems use lexical functional grammar but parsing for grammars this type known complete head driven phrase structure grammar another linguistic formalism which has been popular the parsing but other research efforts have focused less complex formalisms such the one used the penn treebank shallow parsing aims find only the boundaries major constituents such noun another popular strategy for avoiding linguistic controversy dependency grammar parsing most modern parsers are least partly statistical that they rely corpus training data which has already been annotated parsed this approach allows the system gather information about the frequency with which various constructions occur specific see machine learning approaches which have been used include straightforward pcfgs probabilistic free maximum entropy and neural nets most the more successful systems use lexical statistics that they consider the identities the words well their part speech however such systems are vulnerable overfitting and require some kind smoothing citation needed parsing algorithms for natural language cannot rely the grammar having properties with manually designed grammars for programming mentioned earlier some grammar formalisms are very difficult parse even the desired structure not context free some kind free approximation the grammar used perform first algorithms which use free grammars often rely some variant the cky algorithm usually with some heuristic prune away unlikely analyses save see chart parsing however some systems trade speed for accuracy linear time versions the shift reduce algorithm somewhat recent development has been parse reranking which the parser proposes some large number and more complex system selects the best psycholinguistics psycholinguistics parsing involves not just the assignment words but the evaluation the meaning sentence according the rules syntax drawn inferences made from each word the this normally occurs words are being heard consequently psycholinguistic models parsing are necessity incremental meaning that they build interpretation the sentence being which normally expressed terms partial syntactic creation the wrong structure can lead the phenomenon known garden pathing computer languages this section does not cite any references sources please help improve this section adding citations reliable sources unsourced material may challenged and removed february parser parser software component that takes input data frequently and builds data structure often some kind parse tree abstract syntax tree other hierarchical structure giving structural representation the checking for correct syntax the the parsing may preceded followed other these may combined into single the parser often preceded separate lexical analyser which creates tokens from the sequence input alternatively these can combined scannerless parsing parsers may programmed hand may automatically automatically generated parser generator parsing complementary templating which produces formatted output these may applied different but often appear such the scanf printf pair the input front end and output back end code stages the input parser often text some computer language but may also text natural language less structured textual which case generally only certain parts the text are rather than parse tree being parsers range from very simple functions such scanf complex programs such the frontend compiler the html parser web browser important class simple parsing done using regular expressions where regular expression defines regular language and then the regular expression engine automatically generates parser for that allowing pattern matching and extraction other contexts regular expressions are instead used prior the lexing step whose output then used the the use parsers varies the case data parser often found the file reading facility such reading html xml text these examples are markup languages the case programming languages parser component compiler interpreter which parses the source code computer programming language create some form internal the parser key step the compiler frontend programming languages tend specified terms deterministic free grammar because fast and efficient parsers can written for for the parsing itself can done one pass multiple passes see one pass compiler and multi pass compiler the implied disadvantages pass compiler can largely overcome adding where provision made for ups during the forward and the ups are applied backwards when the current program segment has been recognized having been example where such mechanism would useful would forward goto where the target the goto unknown until the program segment this the application the would delayed until the target the goto was obviously backward goto does not require context free grammars are limited the extent which they can express all the requirements informally the reason that the memory such language the grammar cannot remember the presence construct over arbitrarily long this necessary for language for name must declared before may more powerful grammars that can express this however cannot parsed thus common strategy create relaxed parser for free grammar which accepts superset the desired language constructs that accepts some invalid later the unwanted constructs can filtered out the semantic analysis contextual step for python the following syntactically valid print the following however syntactically valid terms the free yielding syntax tree with the same structure the but syntactically invalid terms the sensitive which requires that variables initialized before print rather than being analyzed the parsing this caught checking the values the syntax hence part semantic analysis context sensitive syntax practice often more easily analyzed overview process the following example demonstrates the common case parsing computer language with two levels lexical and the first stage the token lexical analysis which the input character stream split into meaningful symbols defined grammar regular expressions for calculator program would look input such and split into the tokens each which meaningful symbol the context arithmetic the lexer would contain rules tell that the characters and mark the start new meaningless tokens like will not the next stage parsing syntactic which checking that the tokens form allowable this usually done with reference context free grammar which recursively defines components that can make expression and the order which they must however not all rules defining programming languages can expressed free grammars for example type validity and proper declaration these rules can formally expressed with attribute grammars the final phase semantic parsing which working out the implications the expression just validated and taking the appropriate the case calculator the action evaluate the expression the other would generate some kind attribute grammars can also used define these types parsers the task the parser essentially determine and how the input can derived from the start symbol the this can done essentially two top down parsing top down parsing can viewed attempt find most derivations stream searching for parse trees using down expansion the given formal grammar rules tokens are consumed from left inclusive choice used accommodate ambiguity expanding all alternative sides grammar bottom parsing parser can start with the input and attempt rewrite the start intuitively the parser attempts locate the most basic then the elements containing and parsers are examples another term used for this type parser reduce parsers and recursive descent parser are examples down parsers which cannot accommodate left recursive production rules although has been believed that simple implementations down parsing cannot accommodate direct and indirect recursion and may require exponential time and space complexity while parsing ambiguous context free grammars more sophisticated algorithms for down parsing have been created hafiz and callaghan which accommodate ambiguity and left recursion polynomial time and which generate size representations the potentially exponential number parse their algorithm able produce both most and most derivations input with regard given cfg free important distinction with regard parsers whether parser generates leftmost derivation rightmost derivation see context free grammar parsers will generate leftmost derivation and parsers will generate rightmost derivation although usually examples parsers top down parsers some the parsers that use top down parsing include recursive descent parser parser eftmost earley parser parsers some the parsers that use bottom parsing include precedence operator precedence parser simple precedence parser bounded parsing parser ightmost simple parser lalr parser canonical parser glr parser cyk parser recursive ascent parser parser development software some the well known parser development tools include the also see comparison parser generators antlr bison gold javacc jparsec lemon lex parboiled parsec parseit ragel shproto fsm parser spirit parser framework syntax definition formalism syntax xpl yacc lookahead this section does not cite any references sources please help improve this section adding citations reliable sources unsourced material may challenged and removed april lookahead establishes the maximum incoming tokens that parser can use decide which rule should lookahead especially relevant and lalr parsers where often explicitly indicated affixing the lookahead the algorithm name such most programming languages the primary target are carefully defined such way that parser with limited typically can parse because parsers with limited lookahead are often more one important change citation needed this trend came when terence parr created antlr for his thesis parser generator for efficient parsers where any fixed parsers typically have only few actions after seeing each they are shift add this token the stack for later reduce pop tokens from the stack and form syntactic end error known rule conflict does not know whether shift lookahead has two helps the parser take the correct action case for parsing the statement the case else eliminates many duplicate states and eases the burden extra language lookahead parser will have around states lookahead parser will have around states example parsing the expression most programming languages except for few such apl and and algebraic formulas give higher precedence multiplication than which case the correct interpretation the example above note that above semantic possible rewrite the grammar incorporate this into the however not all such rules can translated into initially input shift onto stack from input anticipation input stack reduces expression based stack shift onto stack from input anticipation input stack shift onto stack from input anticipation input stack reduce stack element expression based stack reduce stack items and new input based stack shift onto stack from input anticipation input stack shift onto stack from input anticipation input stack reduce stack element expression based stack reduce stack items and new input based stack the parse tree and resulting code from not correct according language correctly parse without there are three the user has enclose expressions within this often not viable the parser needs have more logic backtrack and retry whenever rule violated not the similar method followed alternatively the parser grammar needs have extra logic delay reduction and reduce only when absolutely sure which rule reduce this method used this correctly parses the expression but with many more states and increased stack shift onto stack input anticipation does not reduce reduce stack item simple expression input based the lookahead are path can reduce the stack shift onto stack input anticipation shift onto stack input anticipation reduce stack item expression input based the lookahead expects only before now stack has and still the input has two choices either shift based reduction based since has more precedence than based shift onto stack anticipation shift onto stack input anticipation reduce stack item expression after seeing end input based reduce stack items based reduce stack items based the parse tree generated correct and simply more efficient citation needed than lookahead this the strategy followed lalr parsers see also backtracking chart parser compiler deterministic parsing generating strings grammar checker lalr parser lexing pratt parser shallow parsing left corner parser parsing expression grammar sdf meta environment dms software reengineering toolkit program transformation source code generation 