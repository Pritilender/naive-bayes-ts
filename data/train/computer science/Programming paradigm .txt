computer science
programming paradigm navigation search this article needs additional citations for verification please help improve this article adding citations reliable sources unsourced material may challenged and february action oriented oriented based concurrent computing relativistic programming driven declarative imperative constraint dataflow flow based oriented spreadsheets reactive functional functional logic logic abductive logic answer set constraint logic functional logic inductive logic user programming driven service oriented driven oriented oriented level value level generic imperative declarative procedural oriented natural language programming specific specific oriented dialecting intentional metaprogramming automatic reflective attribute oriented homoiconic template policy based structured structured array nondeterministic parallel computing process oriented free style concatenative semantic structured non structured block structured modular monolithic object oriented separation concerns aspect oriented oriented oriented based based recursive level function level probabilistic concept programming paradigm fundamental style computer programming way building the structure and elements computer capabilities and styles various programming languages are defined their supported programming paradigms some programming languages are designed follow only one while others support multiple there are six main programming imperative declarative functional object oriented logic and symbolic programming contents overview history machine code procedural languages object oriented programming further paradigms multi paradigm see also references external links overview just software engineering defined differing methodologies the programming languages models are defined differing paradigms some languages are designed support one particular paradigm smalltalk supports oriented haskell supports functional while other programming languages support multiple paradigms such object pascal java scala visual basic common lisp scheme perl python ruby and for programs written object pascal can purely procedural purely object oriented contain elements both software designers and programmers decide how use those paradigm oriented programmers can think program collection interacting while functional programming program can thought sequence stateless function when programming computers systems with many process oriented programming allows programmers think about applications sets concurrent processes acting upon logically shared data structures many programming paradigms are well known for what techniques they forbid for what they for pure functional programming disallows the use side effects while structured programming disallows the use the goto statement partly for this new paradigms are often regarded doctrinaire overly rigid those accustomed earlier avoiding certain techniques can make easier prove theorems about simply understand its programming paradigms can also compared with programming models which are abstractions computer for the von neumann model programming model used traditional sequential for parallel computing there are many possible models typically reflecting different ways processors can the most common are based shared distributed memory with message hybrid the some programming language researchers criticise the notion paradigms classification programming krishnamurthi they argue that many programming languages cannot strictly classified into one but rather include features from several history different approaches programming have developed over being identified such either the time early approach consciously identified such structured programming advocated since the mid the concept programming such dates least the turing award lecture robert floyd entitled the paradigms which cites the notion paradigm used thomas kuhn his the structure scientific revolutions machine code the lowest level programming paradigms are machine code which directly represents the instructions the contents program sequence and assembly language where the machine instructions are represented mnemonics and memory addresses can given symbolic these are sometimes called first and second generation languages the assembly languages were developed support library copy and quite sophisticated conditional macro generation and processing call subroutines external variables and common sections enabling significant code use and isolation from hardware specifics via use logical operators such assembly and still used for time critical systems and frequently embedded systems gives the most direct control what the machine actually procedural languages the next advance was the development procedural languages these third generation languages the first described high level languages use vocabulary related the problem being for cobol common business oriented uses terms like file move and copy fortran formula using mathematical language was developed mainly for scientific and engineering algol algorithmic focused being appropriate language define algorithms while using mathematical language terminology and targeting scientific and engineering problems just like programming language hybrid scientific general purpose language supporting pointers basic beginners all purpose symbolic instruction was developed enable more people write purpose programming initially developed dennis ritchie between and bell labs all these languages follow the procedural that they step exactly the procedure that according the particular programmer followed solve specific the efficacy and efficiency any such solution are both therefore entirely subjective and highly dependent that inventiveness and object oriented programming later object oriented languages like simula smalltalk eiffel and java were these data and methods manipulating the are kept single unit called object the only way that user can access the data via the methods because the internal workings object may changed without affecting any code that uses the there still some controversy notable programmers such alexander stepanov richard stallman and concerning the efficacy the oop paradigm versus the procedural the necessity every object have associative methods leads some skeptics associate oop with software bloat polymorphism was developed one attempt resolve this since oriented programming considered not possible create even oriented assembler high level assembly example this that fully supports advanced data types and oriented assembly language despite its early thus differing programming paradigms can thought more like motivational memes their rather than necessarily representing progress from one level the precise comparisons the efficacy competing paradigms are frequently made more difficult because new and differing terminology applied similar but not entities and processes together with numerous implementation distinctions across further paradigms within imperative programming which based procedural literate programming which structures programs centered hypertext essay documentation integral the and the program structured following the logic prose rather than compiler independent the imperative declarative programming paradigms were these languages the computer told what the problem not how solve the the program structured collection properties find the expected not procedure given database set the computer tries find solution matching all the desired the archetypical example declarative language the fourth generation language sql well the family functional languages and logic programming functional programming subset declarative programs written using this paradigm use functions blocks code intended behave like mathematical functions functional languages discourage changes the value variables through assignment making great deal use recursion instead the logic programming paradigm views computation automated reasoning over corpus facts about the problem domain are expressed logic and programs are executed applying inference rules over them until answer the problem the collection formulae proved symbolic programming paradigm which describes programs able manipulate formulas and program components programs can thus effectively modify and appear learn making them suited for applications such artificial intelligence expert systems natural language processing and computer languages that support this paradigm include lisp and prolog multi paradigm comparison paradigm programming languages multi paradigm programming language programming language that supports more than one programming leda designer timothy budd puts the idea multiparadigm language provide framework which programmers can work variety freely intermixing constructs from different the design goal such languages allow programmers use the best tool for admitting that one paradigm solves all problems the easiest most efficient one example which includes imperative and object oriented paradigms well some support for functional programming through type inference anonymous functions and language integrated query some other ones are and scala which provides similar functionality but also includes full support for functional programming including currying pattern matching algebraic data types lazy evaluation tail recursion immutability etc perhaps the most extreme example which has subsets that adhere logic descends from logic functional object oriented dataflow concurrent and other was designed over year period combine harmonious way concepts that are traditionally associated with different programming lisp while often taught functional known for its malleability and thus its ability engulf many see also comparison programming paradigms type system architecture description language specific language mindset modeling language paradigm programming domain turing completeness von neumann programming languages 