computer science	symbolic computation navigation search symbolic execution mathematics and computer science computer algebra also called symbolic computation algebraic computation scientific area that refers the study and development algorithms and software for manipulating mathematical expressions and other mathematical objects although properly computer algebra should subfield scientific computing they are generally considered distinct fields because scientific computing usually based numerical computation with approximate floating point numbers while computer algebra emphasizes exact computation with expressions containing variables that have not any given value and are thus manipulated symbols therefore the name symbolic computation software applications that perform symbolic calculations are called computer algebra systems with the term system alluding the complexity the main applications that method represent mathematical data user programming language usually different from the language used for the dedicated memory user interface for the output mathematical large set routines perform usual like simplification differentiation using chain rule polynomial factorization indefinite integration etc the beginning computer circa when the known algorithms were first put they turned out highly therefore large part the work the searchers the field consisted revisiting classical algebra order make effective and discover efficient algorithms implement this typical example this kind work the computation polynomial greatest common divisors which required simplify surprisingly the classical euclid algorithm turned out inefficient for polynomials over infinite and thus new algorithms needed the same was also true for the classical algorithms from linear algebra computer algebra widely used experiment mathematics and design the formulas that are used numerical also used for complete scientific when purely numerical methods like public key cryptography for some non linear problems contents terminology scientific community computer science aspects data representation numbers expressions simplification mathematical aspects equality see also references further reading terminology some authors distinguish computer algebra from symbolic computation using the latter name refer kinds symbolic computation other than the computation with mathematical some authors use symbolic computation for the computer science aspect the subject and computer for the mathematical some languages the name the field not direct translation its english typically called calcul formel which means formal symbolic computation has also been referred the symbolic manipulation algebraic manipulation symbolic processing symbolic mathematics symbolic algebra but these which also refer computational are more use for referring computer scientific community there learned society that specific computer but this function assumed the special interest group the association for computing machinery named sigsam special interest group symbolic and algebraic there are several annual conferences computer the premier being issac international symposium symbolic and algebraic which regularly sponsored there are several journals specializing computer the top one being journal symbolic computation founded bruno buchberger there are also several other journals that regularly publish articles computer computer science aspects this section does not cite any references sources please help improve this section adding citations reliable sources unsourced material may challenged and removed november data representation numerical software are highly efficient for approximate numerical computation computer emphasize exact computation with exactly represented such exact representation implies even when the size the output then the intermediate data that are generated during computation may grow unpredictable this behavior called expression swell obviate this various methods are used the representation the well the algorithms that manipulate numbers the usual numbers systems used numerical computation are either the floating point numbers and the integers fixed bounded that are improperly called integers most programming languages none convenient for computer because the expression therefore the basic numbers used computer algebra are the integers the commonly represented unbounded signed sequence digits some base numeration usually the largest base allowed the machine word these integers allow define the rational numbers which are irreducible fractions two programming efficient implementation the arithmetic operations hard therefore most free computer algebra systems and some commercial like maple use the gmp library which thus facto standard expressions except for numbers and variables every mathematical expression may viewed the symbol operator followed sequence computer algebra the expressions are usually represented this this representation very and many that seem not mathematical expressions first may represented and manipulated for equation expression with matrix may represented expression with operator and its rows even programs may considered and represented expressions with operator and two the list parameters and the which itself expression with operator and sequence instructions conversely any mathematical expression may viewed for the expression may viewed program for the with and executing this program consists evaluating the expression for given values and they not have any that they are the result the evaluation simply its this process delayed evaluation fundamental computer for the operator the equations most computer algebra the name the program the equality normally the evaluation equation results but when equality test either explicitly asked the user through evaluation command automatically started the system the case test inside then the evaluation boolean the size the operands expression unpredictable and may change during working the sequence the operands usually represented sequence either pointers like macsyma entries hash table like maple simplification the raw application the basic rules differentiation with respect the expression gives the result such awful expression clearly not and procedure simplification needed soon one works with general this simplification normally done through rewriting rules there are several classes rewriting rules that have the simplest one consist the rewriting rules that always reduce the size the like sin they are systematically applied the computer algebra the first difficulty occurs with associative operations like addition and the standard way deal with associativity consider that addition and multiplication have arbitrary number that that represented what about deal with this the simplest way rewrite systematically respectively other the internal representation the there subtraction division unary outside the representation the second difficulty occurs with the commutativity addition and the problem recognize quickly the like terms order combine canceling the method for finding like consisting testing every pair too costly for being practicable with very long sums and for solving this macsyma sorts the operands sums and products with function comparison that designed order that like terms are consecutive and thus easily maple the hash function designed for generating collisions when like terms are allowing combine them soon they are this design the hash function allows also recognize immediately the expressions subexpressions that appear several times computation and store them only this allows not only save some memory but also speed the avoiding repeat the same computation several identical some rewriting rules sometimes increase and sometimes decrease the size the expressions which they are this the case distributivity trigonometric identities for example the distributivity law allows rewriting and there way make good general choice applying not such rewriting such rewritings are done only when explicitly asked the for the the computer function that apply this rewriting rule generally called expand the reverse rewriting called factor requires trivial which thus key function computer algebra systems see polynomial factorization mathematical aspects this section consider some fundamental mathematical questions that arise soon one want manipulate mathematical expressions consider mainly the case the multivariate rational fractions this not real because soon the irrational functions appearing expression are they are usually considered new for example viewed polynomial and equality there are two notions equality for mathematical expressions the syntactic equality the equality the expressions which means that they are written represented the same rarely considered but the only equality that easy test with the semantic equality when two expressions represent the same mathematical like known that there may not exist algorithm that decides two expressions representing numbers are semantically exponentials and logarithms are allowed the therefore equality may tested only some classes expressions such the polynomials and the rational fractions test the equality two instead design specific usual put them some canonical form put their difference normal form and test the syntactic equality the unlike usual canonical and normal are not synonymous computer canonical form such that two expressions canonical form are semantically equal and only they are syntactically while normal form such that expression normal form semantically zero only syntactically other words zero has unique representation expressions normal normal forms are usually preferred computer algebra for several firstly canonical forms may more costly compute than normal for put polynomial canonical one has expand distributivity every while not necessary with normal form see secondly may the like for expressions involving that canonical depends some arbitrary choices and that these choices may different for two expressions that have been computed this may make impracticable the use canonical see also automated theorem prover assisted proof computer algebra system proof checker model checker numeric computation symbolic simulation 